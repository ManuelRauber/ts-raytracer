#version 460
#extension GL_GOOGLE_include_directive : enable

#include "utils.comp"
#include "materials.comp"
#include "ray.comp"
#include "camera.comp"

//#define FLT_MAX 3.402823466e+38
#define FLT_MAX 99999.99
//const float INFINITY     = 1. / 0.;

layout(set = 0, binding = 0) uniform ComputeParams {
  float fWidth;
  float fHeight;
  float fSamplesPerPixel;
  float fMaxBounces;
  float fSphereCount;
  float fRandomSeed;
}
params;

layout(std140, set = 0, binding = 1) buffer RandomScene {
  vec4 sceneArray[];
}
randomScene;

layout(std140, set = 0, binding = 2) buffer PixelBuffer {
  vec4 pixels[];
}
pixelBuffer;

struct Sphere {
  vec3  center;
  float radius;
  float materialType;
  vec3  albedo;
  float roughness;
  float refractIdx;
};

bool hitSphere(const Sphere s, const Ray r, float t_min, float t_max, inout HitRecord rec) {
  vec3  oc           = r.origin - s.center;
  float a            = lengthSquared(r.direction);
  float half_b       = dot(oc, r.direction);
  float c            = lengthSquared(oc) - s.radius * s.radius;
  float discriminant = half_b * half_b - a * c;

  if (discriminant > 0) {
    float root = sqrt(discriminant);
    float temp = (-half_b - root) / a;
    if (temp < t_max && temp > t_min) {
      rec.t               = temp;
      rec.p               = rayAt(r, rec.t);
      vec3 outward_normal = (rec.p - s.center) / s.radius;
      setFaceNormal(rec, r, outward_normal);
      rec.materialType = s.materialType;
      rec.albedo       = s.albedo;
      rec.roughness    = s.roughness;
      rec.refractIdx   = s.refractIdx;
      return true;
    }
    temp = (-half_b + root) / a;
    if (temp < t_max && temp > t_min) {
      rec.t               = temp;
      rec.p               = rayAt(r, rec.t);
      vec3 outward_normal = (rec.p - s.center) / s.radius;
      setFaceNormal(rec, r, outward_normal);
      rec.materialType = s.materialType;
      rec.albedo       = s.albedo;
      rec.roughness    = s.roughness;
      rec.refractIdx   = s.refractIdx;
      return true;
    }
  }
  return false;
}

bool hittablesHit(const Ray r, float t_min, float t_max, inout HitRecord rec) {
  HitRecord temp_rec;
  bool      hit_anything   = false;
  float     closest_so_far = t_max;
  const int count          = int(params.fSphereCount);

  int idx = 0;
  for (int i = 0; i < count; i++) {
    vec4 v1 = randomScene.sceneArray[idx++];
    vec4 v2 = randomScene.sceneArray[idx++];
    vec4 v3 = randomScene.sceneArray[idx++];

    Sphere sphere;
    sphere.center       = v1.xyz;
    sphere.radius       = v1.w;
    sphere.materialType = v2.x;
    sphere.albedo       = v2.yzw;
    sphere.roughness    = v3.x;
    sphere.refractIdx   = v3.y;

    // Sphere sphere2 = Sphere(vec3(0.0, -1000, 0.0), 1000, MATERIAL_LAMBERT, vec3(0.5, 0.5, 0.5), 0.0, 1.0);
    Sphere sphere2 = Sphere(sphere.center, sphere.radius, sphere.materialType, sphere.albedo, sphere.roughness, sphere.refractIdx);

    if (hitSphere(sphere2, r, t_min, closest_so_far, temp_rec)) {
      hit_anything   = true;
      closest_so_far = temp_rec.t;
      rec            = temp_rec;
    }
  }

  return hit_anything;
}

vec3 rayColor(Ray ray, uint depth) {
  HitRecord rec;
  vec3      color = vec3(1.0, 1.0, 1.0);

  for (int i = 0; i < depth; i++) {
    if (hittablesHit(ray, 0.001, FLT_MAX, rec)) {
      Ray  newRay;
      vec3 attenuation;

      bool wasScattered = materialBSDF(ray, rec, attenuation, newRay);

      ray.origin    = newRay.origin;
      ray.direction = newRay.direction;

      if (wasScattered) {
        color *= attenuation;
      } else {
        color *= vec3(0.0, 0.0, 0.0);
        break;
      }

    } else {
      vec3  unit_direction = normalize(ray.direction);
      float t              = 0.5 * (unit_direction.y + 1.0);
      vec3  skyColor       = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
      color *= skyColor;
      break;
    }
  }

  return color;
}

void main() {
  uint index = gl_GlobalInvocationID.x;

  float j = params.fHeight - (floor(float(index) / params.fWidth));
  float i = mod(float(index), params.fWidth);

  //initSeed(index * 1099087573U);
  initSeed(index * uint(floor(params.fRandomSeed * 100000000U)));

  float aspectRatio = params.fWidth / params.fHeight;

  vec3  lookFrom = {13.0, 2.0, 3.0};
  vec3  lookAt   = {0.0, 0.0, 0.0};
  vec3  vUp      = {0.0, 1.0, 0.0};
  float vfoY     = 20;
  float aperture = 0.0;
  //float focusDistance = length(lookFrom - lookAt);
  float focusDistance = 10.0;

  Camera camera = createCamera(lookFrom, lookAt, vUp, vfoY, aspectRatio, aperture, focusDistance);

  /*
  {{0.0, -100.5, -1.0}, 100, MATERIAL_LAMBERT, {0.8, 0.8, 0.0}, 0.0, 1.0},
  {{0.0, 0.0, -1.0}, 0.5, MATERIAL_LAMBERT, {0.1, 0.2, 0.5}, 0.0, 1.0},
  {{1.0, 0.0, -1.0}, 0.5, MATERIAL_METAL, {0.8, 0.6, 0.2}, 0.05, 1.0},
  {{-1.0, 0.0, -1.0}, 0.5, MATERIAL_DIELECTRIC, {1.0, 1.0, 1.0}, 1.0, 1.5},
  */

  //{{1.0, 0.0, -2.5}, 0.5, MATERIAL_METAL, {0.8, 0.6, 0.2}, 0.8, 1.0},

  vec3 pixel_color = vec3(0.0, 0.0, 0.0);

  const uint ssp     = uint(params.fSamplesPerPixel);
  const uint bounces = uint(params.fMaxBounces);

  // for (int s = 0; s < ssp; s++) {
  float u = (i + random()) / (params.fWidth - 1.0);
  float v = (j + random()) / (params.fHeight - 1.0);
  Ray   r = cameraGetRay(camera, u, v);
  pixel_color += rayColor(r, bounces);
  // }

  // float scale = 1.0 / params.fSamplesPerPixel;
  // pixel_color *= scale;
  //pixel_color = vec3(random());

  // gamma correction
  pixel_color = sqrt(pixel_color);

  //pixel_color               = randomVec3();
  pixelBuffer.pixels[index] = vec4(pixel_color, 1.0);
}

/*

  0 1 2 3
0 * * * *
1 * * * *
2 * * * *
3 * * * *

11

*/
