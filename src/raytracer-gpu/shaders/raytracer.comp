#version 460
#extension GL_GOOGLE_include_directive : enable

#include "utils.glsl"

const float infinity = 1. / 0.;
#define FLT_MAX 3.402823466e+38

layout(set = 0, binding = 0) uniform ComputeParams {
  float fWidth;
  float fHeight;
  float fSamplesPerPixel;
  float fMaxBounces;
}
params;

layout(std140, set = 0, binding = 1) buffer PixelBuffer {
  vec4 pixels[];
}
pixelBuffer;

struct Ray {
  vec3 orig;
  vec3 dir;
};

struct HitRecord {
  vec3  p;
  vec3  normal;
  float t;
  bool  frontFace;
};

struct Sphere {
  vec3  center;
  float radius;
};

void setFaceNormal(inout HitRecord rec, const Ray r, const vec3 outwardNormal) {
  rec.frontFace = dot(r.dir, outwardNormal) < 0;
  rec.normal    = rec.frontFace ? outwardNormal : -outwardNormal;
}

vec3 unitVector(const vec3 v) {
  return v / length(v);
}

float lengthSquared(const vec3 v) {
  return v.x * v.x + v.y * v.y + v.z * v.z;
}

vec3 rayAt(const Ray ray, const float t) {
  return ray.orig + t * ray.dir;
}

bool hitSphere(const Sphere s, const Ray r, float t_min, float t_max, inout HitRecord rec) {
  vec3  oc           = r.orig - s.center;
  float a            = lengthSquared(r.dir);
  float half_b       = dot(oc, r.dir);
  float c            = lengthSquared(oc) - s.radius * s.radius;
  float discriminant = half_b * half_b - a * c;

  if (discriminant > 0) {
    float root = sqrt(discriminant);
    float temp = (-half_b - root) / a;
    if (temp < t_max && temp > t_min) {
      rec.t               = temp;
      rec.p               = rayAt(r, rec.t);
      vec3 outward_normal = (rec.p - s.center) / s.radius;
      setFaceNormal(rec, r, outward_normal);
      return true;
    }
    temp = (-half_b + root) / a;
    if (temp < t_max && temp > t_min) {
      rec.t               = temp;
      rec.p               = rayAt(r, rec.t);
      vec3 outward_normal = (rec.p - s.center) / s.radius;
      setFaceNormal(rec, r, outward_normal);
      return true;
    }
  }
  return false;
}

bool hittablesHit(const Sphere spheres[2], const Ray r, float t_min, float t_max, inout HitRecord rec) {
  HitRecord temp_rec;
  bool      hit_anything   = false;
  float     closest_so_far = t_max;

  for (int i = 0; i < 2; i++) {
    if (hitSphere(spheres[i], r, t_min, closest_so_far, temp_rec)) {
      hit_anything   = true;
      closest_so_far = temp_rec.t;
      rec            = temp_rec;
    }
  }

  return hit_anything;
}

vec3 rayColor(const Ray r, const Sphere spheres[2]) {
  HitRecord rec;
  if (hittablesHit(spheres, r, 0, FLT_MAX, rec)) {
    return 0.5 * (rec.normal + vec3(1.0, 1.0, 1.0));
  }

  vec3  unit_direction = unitVector(r.dir);
  float t              = 0.5 * (unit_direction.y + 1.0);
  return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

void main() {
  uint index = gl_GlobalInvocationID.x;
  initSeed(index * 1099087573U);

  float j = params.fHeight - (floor(float(index) / params.fWidth));
  float i = mod(float(index), params.fWidth);

  float aspect_ratio      = params.fWidth / params.fHeight;
  float viewport_height   = 2.0;
  float viewport_width    = aspect_ratio * viewport_height;
  float focal_length      = 1.0;
  vec3  origin            = vec3(0.0, 0.0, 0.0);
  vec3  horizontal        = vec3(viewport_width, 0, 0);
  vec3  vertical          = vec3(0, viewport_height, 0);
  vec3  lower_left_corner = origin - horizontal / 2 - vertical / 2 - vec3(0, 0, focal_length);

  Sphere spheres[2] = {
      {{0.0, 0.0, -1.0}, 0.5},
      {{0.0, -100.5, -1.0}, 100}};

  vec3 pixel_color = vec3(0.0, 0.0, 0.0);

  const uint ssp = uint(params.fSamplesPerPixel);

  for (int s = 0; s < ssp; s++) {
    float u = (i + rand()) / (params.fWidth - 1.0);
    float v = (j + rand()) / (params.fHeight - 1.0);
    Ray   r = Ray(origin, lower_left_corner + u * horizontal + v * vertical - origin);
    pixel_color += rayColor(r, spheres);
  }

  //vec3 pixel_color = vec3(rand(), rand(), rand());
  float scale = 1.0 / params.fSamplesPerPixel;
  pixel_color *= scale;

  pixelBuffer.pixels[index] = vec4(pixel_color, 1.0);
}

/*

  0 1 2 3
0 * * * *
1 * * * *
2 * * * *
3 * * * *

11

*/